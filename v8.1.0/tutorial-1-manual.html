<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Manual - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  <!-- https://realfavicongenerator.net/ -->
  
    <link
      
      rel="apple-touch-icon" 
      
      sizes="180x180" 
      
      href="apple-touch-icon.png" 
      
    >
  
    <link
      
      rel="icon" 
      
      type="image/png" 
      
      sizes="32x32" 
      
      href="favicon-32x32.png" 
      
    >
  
    <link
      
      rel="icon" 
      
      type="image/png" 
      
      sizes="16x16" 
      
      href="favicon-16x16.png" 
      
    >
  
    <link
      
      rel="manifest" 
      
      href="site.webmanifest" 
      
    >
  
    <link
      
      rel="mask-icon" 
      
      type="image/png" 
      
      sizes="16x16" 
      
      href="safari-pinned-tab.svg" 
      
      color="#ffab40" 
      
    >
  
    <link
      
      type="text/css" 
      
      rel="stylesheet" 
      
      href="pkg-styles/pkg-style.css" 
      
    >
  

  
    <meta
      
      name="msapplication-TileColor" 
      
      content="#ffab40" 
      
    >
  
    <meta
      
      name="theme-color" 
      
      content="#bdbdbd" 
      
    >
  
    <meta
      
      name="viewport" 
      
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" 
      
    >
  

  <link type="text/css" rel="stylesheet" href="jsdocp/styles/index.css"></head>
<body><div id="jsdocpNav" class="jsdocp-remove-me pkg-menu"
  data-jsdocp-sm-position="bottom"
  data-jsdocp-md-position="bottom"
  data-jsdocp-lg-position="top"
  data-jsdocp-sm-match-media="(max-width: 480px)"
  data-jsdocp-md-match-media="(min-width: 481px) and (max-width: 839px)"
  data-jsdocp-lg-match-media="(min-width: 840px)"
  data-jsdocp-sm-auto-hide="true"
  data-jsdocp-md-auto-hide="true"
  data-jsdocp-lg-auto-hide="false">
  <a href="index.html" id="jsdocpLogo"
    title="sqler"
    class="jsdocp-logo ">
    <b class="pkg-logo">
    
      <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg viewBox="0 0 29.26 29.26" y="0px" x="0px" version="1.1">
<g>
	<path
   d="M 3.2714844 12.164062 C 3.0504844 12.547062 2.921875 12.944422 2.921875 13.357422 L 2.921875 16.919922 C 2.921875 19.670922 8.1639531 21.902344 14.626953 21.902344 C 21.093953 21.902344 26.337891 19.670922 26.337891 16.919922 L 26.337891 13.357422 C 26.337891 12.944422 26.207375 12.547062 25.984375 12.164062 C 25.170706 13.571962 22.944745 14.736211 19.992188 15.388672 C 19.990472 16.830619 19.968304 18.235467 19.923828 18.3125 C 19.831308 18.472746 14.767068 21.396484 14.582031 21.396484 C 14.396995 21.396484 9.3327528 18.472746 9.2402344 18.3125 C 9.1955638 18.235128 9.175362 16.819813 9.1738281 15.371094 C 6.2660228 14.715075 4.0769893 13.558477 3.2714844 12.164062 z "
   />
	<path
   d="M14.627,23.31c-5.494,0-10.098-1.616-11.355-3.788c-0.221,0.381-0.35,0.779-0.35,1.191v3.564   c0,2.752,5.242,4.983,11.705,4.983c6.467,0,11.711-2.23,11.711-4.983v-3.564c0-0.412-0.131-0.81-0.354-1.19   C24.727,21.694,20.127,23.31,14.627,23.31z"
   />
	<path
   d="M 3.2402344 5.0429688 C 3.0392344 5.4089688 2.921875 5.7905937 2.921875 6.1835938 L 2.921875 9.7441406 C 2.921875 11.658469 5.4621005 13.319742 9.1816406 14.154297 C 9.1905174 13.111949 9.205954 12.203907 9.2402344 12.144531 C 9.3327524 11.984284 14.396995 9.0605469 14.582031 9.0605469 C 14.767068 9.0605469 19.83131 11.984284 19.923828 12.144531 C 19.958305 12.204246 19.975593 13.121262 19.984375 14.171875 C 23.754868 13.344294 26.337891 11.674559 26.337891 9.7441406 L 26.337891 6.1835938 C 26.337891 5.7905938 26.218578 5.4099687 26.017578 5.0429688 C 25.787578 7.0589688 20.785953 8.671875 14.626953 8.671875 C 8.4709531 8.671875 3.4692344 7.0579688 3.2402344 5.0429688 z "
   />
	<path
   d="M14.627,7.541c6.303,0,11.41-1.687,11.41-3.771c0-2.082-5.107-3.77-11.41-3.77   C8.328,0.001,3.219,1.689,3.219,3.771C3.219,5.854,8.328,7.541,14.627,7.541z"
   />
</g>
</svg>

    
    </b>
    <b id="jsdocpPkgName">sqler</b>
    <b>|</b>
    <hr/>
  </a>
  <a href="https://www.npmjs.com/package/sqler" id="jsdocpModule"
    title="npm"
    class="jsdocp-icon ">
    
    <svg version="1.1" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24" height="24" width="24" xmlns="http://www.w3.org/2000/svg">
      <g class="jsdocp-icon-svg-el pkg-icons" stroke="none" transform="translate(0,24) scale(0.1,-0.1)">
        <path d="M 0,120 0,0 l 120,0 120,0 0,120 0,120 -120,0 -120,0 z m 200,0 c 0,-73 0.23256,-80 0.23256,-80 0,0 -27.97435,0.741211 -40.61273,0.707427 C 159.61983,67.551504 160,70.949947 160,100 c 0,53 -2,60 -20,60 -18,0 -20,-7 -20,-60 l 0,-60 -40,0 -40,0 0,80 0,80 80,0 80,0 z"/>
      </g>
    </svg>
    
  </a>
  <a href="CHANGELOG.html" id="jsdocpChangelog" data-jsdocp-root-href="https://ugate.github.io/sqler/CHANGELOG.html"
    title="Changelog"
    class="jsdocp-icon ">
    
    <svg version="1.1" viewBox="0 0 64 64" height="64" width="64" xmlns="http://www.w3.org/2000/svg">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="M 29.896194,0.97873581 C 13.435048,0.97873581 1.1072664e-7,15.139296 0,32.489368 0,49.839439 13.435048,64 29.896194,64 46.357339,64 59.792385,49.839438 59.792388,32.489368 a 4.2273908,4.4556761 0 1 0 -8.453721,0 c -10e-7,12.534501 -9.550175,22.600399 -21.442473,22.600399 -11.892299,0 -21.4424739,-10.065899 -21.4424739,-22.600399 0,-12.5345 9.5501749,-22.6003988 21.4424739,-22.6003988 a 4.2273908,4.4556761 0 1 0 0,-8.91023339 z" />
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 55.529412,24.680907 -8.470588,10.142582 16.941176,0 z"/>
      <rect class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        transform="matrix(0.6882785,0.72544656,-0.6882785,0.72544656,0,0)" y="-38.592953" x="38.592953" height="39.814472" width="11.375563" />
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 23.705056,39.295314 8.338477,-1.11407 -7.281487,-7.674698 z"/>
    </svg>
    
  </a>
  <a href="https://github.com/ugate/sqler.git" id="jsdocpSourceCode"
    title="Source Code"
    class="jsdocp-icon ">
    
    <svg version="1.1" viewBox="0 0 10 16" width="24" height="24" xmlns="http://www.w3.org/2000/svg" id="jsdocpSourceIcon">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="evenodd"
        d="M8 1a1.993 1.993 0 0 0-1 3.72V6L5 8 3 6V4.72A1.993 1.993 0 0 0 2 1a1.993 1.993 0 0 0-1 3.72V6.5l3 3v1.78A1.993 1.993 0 0 0 5 15a1.993 1.993 0 0 0 1-3.72V9.5l3-3V4.72A1.993 1.993 0 0 0 8 1zM2 4.2C1.34 4.2.8 3.65.8 3c0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zm3 10c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zm3-10c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2z"></path>
    </svg>
    <!-- GitHub icon -->
    <svg version="1.1" viewBox="0 0 16 16" height="24" width="24" xmlns="http://www.w3.org/2000/svg" class="jsdocp-remove-me" id="jsdocpGithubIcon">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none"  fill-rule="evenodd"
        d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/>
    </svg>
    
  </a>
  <!-- versions.json should point to the latest list -->
  <a id="jsdocpVersionsIcon"
    class="jsdocp-icon ">
    
    <svg version="1.1" viewBox="0 0 64 64" height="24" width="24" xmlns="http://www.w3.org/2000/svg">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 63.999999,25.315556 -24.108295,0 9.74288,-10.026667 C 39.927261,5.6888885 24.210644,5.3333335 14.503322,14.933333 c -9.7073234,9.635555 -9.7073234,25.173334 0,34.808888 9.707322,9.635556 25.423939,9.635556 35.131262,0 4.835883,-4.764443 7.253823,-10.346666 7.253823,-17.386666 l 7.111592,0 c 0,7.039999 -3.1291,16.177777 -9.387301,22.364444 -12.480844,12.373334 -32.748879,12.373334 -45.2297224,0 -12.445286,-12.337778 -12.55196,-32.39111 -0.071116,-44.7288881 12.4808434,-12.3377774 32.4999734,-12.3377774 44.9808174,0 L 64,-5e-7 64,25.315556 Z" />
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 33.775734,17.777777 0,15.111111 12.445286,7.395556 -2.560173,4.302222 -15.218806,-9.031112 0,-17.777777 5.333693,0 z" />
    </svg>
    
  </a>
  <select id="jsdocpVersions"
    title="v8.1.0"
    data-jsdocp-version-base="/sqler"
    data-jsdocp-json-url="/sqler/versions.json"
    data-jsdocp-type=""
    data-jsdocp-from="1.0.0"
    data-jsdocp-version="8.1.0">
  </select>
</div>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Tutorials</li><li class="nav-item"><a href="tutorial-1-manual.html">Manual</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Dialect.html">Dialect</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Dialect.html#beginTransaction">beginTransaction</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Dialect.html#close">close</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Dialect.html#exec">exec</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Dialect.html#init">init</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Manager.html">Manager</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Manager.html#.namedBindSequence">namedBindSequence</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Manager.html#addConnection">addConnection</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Manager.html#close">close</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Manager.html#generateCacheKey">generateCacheKey</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Manager.html#getCacheKey">getCacheKey</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Manager.html#init">init</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Manager.html#preparedFunctionCount">preparedFunctionCount</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Manager.html#scan">scan</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Manager.html#setCache">setCache</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Manager.html#state">state</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">Manual</h1>
    

    <section>

<header>
    
</header>

<article>
    <h3>🔧 The Manager</h3>
<p>The <a href="Manager.html">Manager</a> is the entry point for one or more databases/connections. The manager basically consolidates each database connection(s) into a single API. One of the major advantages to this simplistic approach is that service calls from javascript to SQL and back can have no vendor-specific references. That translates into a clean seperation of concerns between the two, allowing SQL changes (or even database swapping) to be made without changing any javascript. In contrast to typical ORM solutions, optimations can be applied directly to the SQL scripts, eliminates javascript edits as SQL scripts evolve, removes the need to generate entity definitions and reduces the complexity of the supporting API (thus making it easier to implement and support additional database vendors/drivers).</p>
<blockquote>
<p>TOC</p>
</blockquote>
<ul>
<li><a href="global.html">👀 Globals</a></li>
<li><a href="#conf">⚙️ Setup &amp; Configuration</a></li>
<li><a href="#sqlf">🗃️ SQL Files</a>
<ul>
<li><a href="#es">1️⃣ Expanded SQL Substitutions</a></li>
<li><a href="#fs">2️⃣ Fragment Substitutions</a></li>
<li><a href="#ds">3️⃣ Dialect Substitutions</a></li>
<li><a href="#vs">4️⃣ Version Susbstitutions</a></li>
<li><a href="#rs">5️⃣ Raw Substitutions</a></li>
</ul>
</li>
<li><a href="#tx">🎬 Transactions</a></li>
<li><a href="#ps">🍽️ Prepared Statements</a></li>
<li><a href="#streams">💧 Read/Write Streams</a></li>
<li><a href="#cache">🗄️ Caching SQL</a></li>
</ul>
<h4>⚙️ Setup &amp; Configuration <ins id="conf"></ins>:</h4>
<p>There are two types of configuration, <em>public</em> and <em>private</em>. Public configurations contain one or more <code>connections</code> that will be established during initialization and typically vary depending upon the environment being used (e.g. development, test, ci, production, etc.). See the <a href="Manager.html">manager.connections in the database manager constructor</a> for a complete listing of public configuration options. Private or <em>universal</em> (<code>univ</code>) configuration, on the other hand, is intended to carry sensitive information like connection credentials. Each public connection should contain a <code>conf.db.connections[].id</code> that matches a property name in the private configuration <code>conf.univ.db </code>. <strong>Both public and private configurations are combined when passed into the <a href="Manager.html">Manager</a>, but shoud be loaded from separate sources</strong>. The following example illustrates this using a matching <code>myId</code>:</p>
<pre class="prettyprint source lang-sql"><code>-- db/finance/read.ap.companies.sql
SELECT CO.COMPANY AS &quot;company&quot;, CO.R_NAME AS &quot;name&quot;, CO.PAY_GROUP AS &quot;payGroup&quot;, CO.TAX_ACCOUNT AS &quot;taxAccount&quot;, CO.TAX_ACCT_UNIT AS &quot;taxAcctUnit&quot;,
CO.TAX_SUB_ACCT AS &quot;taxSubAcct&quot;
FROM APCOMPANY CO
WHERE CO.INVOICE_AUDIT = :invoiceAudit
ORDER BY CO.COMPANY ASC
</code></pre>
<pre class="prettyprint source lang-js"><code>// replace xxxx with one of the prexisiting vendor implementations
// or roll your own Dialect
const dialect = 'xxxx', dialectModule = `sqler-${dialect}`;
const { Manager } = require('sqler');
const conf = {
  &quot;univ&quot;: {
    &quot;db&quot;: {
      &quot;myId&quot;: {
        &quot;host&quot;: &quot;myhost.example.com&quot;,
        &quot;username&quot;: &quot;myusername&quot;,
        &quot;password&quot;: &quot;mypassword&quot;
      }
    }
  },
  &quot;db&quot;: {
    &quot;dialects&quot;: {
      [dialect]: dialectModule
    },
    &quot;connections&quot;: [
      {
        &quot;id&quot;: &quot;myId&quot;,
        &quot;name&quot;: &quot;fin&quot;,
        &quot;dir&quot;: &quot;db/finance&quot;,
        &quot;service&quot;: &quot;MYSRV&quot;,
        // global bind variables for all SQLs on connection
        &quot;binds&quot;: {
          &quot;blankDate&quot;: &quot;01-jan-1700&quot;,
          &quot;dateFormat&quot;: &quot;yyyy-mm-dd\&quot;T\&quot;hh24:mi:ss.ff3\&quot;Z\&quot;&quot;
        },
        &quot;sql&quot;: {
          &quot;dialect&quot;: dialect
        }
      }
    ]
  }
};
const mgr = new Manager(conf);
// initialize connections and set SQL functions
await mgr.init();

console.log('Manager is ready for use');

// execute the SQL source and capture the results
const rslts = await mgr.db.fin.read.ap.companies({ binds: { invoiceAudit: 'Y' } });

// after we're done using the manager we should close it
process.on('SIGINT', async function sigintDB() {
  await mrg.close();
  console.log('Manager has been closed');
});
</code></pre>
<p>Each <code>conf.db.dialect</code> property should contain all of the <a href="Dialect.html">Dialect</a> vendor/driver implmentations used by the manager and can be set to either an extending Dialect class or a <em>path</em> to an extended Dialect module. Many Dialects have already been implemented in separate modules that <a href="index.html#dialects">listed in the README.md</a>. The prior example calls <code>mgr.db.fin.ap.list.companies()</code> that uses the <code>conf.db.connections[].name = &quot;fin&quot;</code> as the property namespace under <code>db</code> on the manager instance.</p>
<blockquote>
<p>💡 TIP: Thrown errors from SQL execution will contain a property called <code>sqler</code> that will contain more descriptive error details pertaining to the SQL error.</p>
</blockquote>
<h4>🗃️ <u>SQL Files</u> <ins id="sqlf"></ins>:</h4>
<p>Every SQL file used by <code>sqler</code> should be organized in a directory under the directory assigned to <code>conf.mainPath</code> (defaults to <code>process.main</code> or <code>process.cwd()</code>). Each subdirectory used should be <em>unique</em> to an individual <code>conf.db.connections[].name</code> (default) or <code>conf.db.connections[].dir</code>. When the <a href="Manager.html">Manager</a> is initialized (i.e. <a href="Manager.html#init">Manager.init</a>) the directory is scanned for files with an <code>.sql</code> extension and generates an <a href="global.html#SQLERPreparedFunction">Prepared Function</a> for each file that is found. Each <a href="global.html#SQLERPreparedFunction">generated SQL function</a> will be accessible as a property path of the manager. For instance, a <code>mainPath</code> of <code>/some/sql/path</code> and a connection with a <code>conf.db.connections[].name</code> of <code>conn1</code> would look for SQL files under <code>/some/sql/path/conn1</code>. If <code>conf.db.connections[].dir</code> was set to <code>otherDir</code> then SQL files would be prepared from <code>some/sql/path/otherDir</code> instead. In either case the <a href="global.html#SQLERPreparedFunction">generated prepared SQL function</a> would be accessible via <code>manager.db.conn1.read.something()</code>, assuming that <code>read.something.sql</code> resides in the forementioned directory path. To better visualize path computation, consider the following directory structure and the configuration from the previous example:</p>
<pre class="prettyprint source"><code>.
+ -- db
|    + -- finance
|    |    + -- ap
|    |    |    + -- delete.audits.sql
|    |    |    + -- update.audits.sql
|    |    + -- ar
|    |    |    + -- delete.audits.sql
|    |    |    + -- update.audits.sql
|    |    + -- create.annual.report.sql
|    |    + -- read.annual.report.sql
</code></pre>
<p>The subsequent SQL prepared functions would be gernerated on the manager instance:</p>
<ul>
<li><code>mgr.db.fin.ap.delete.audits()</code></li>
<li><code>mgr.db.fin.ap.update.audits()</code></li>
<li><code>mgr.db.fin.ar.delete.audits()</code></li>
<li><code>mgr.db.fin.ar.update.audits()</code></li>
<li><code>mgr.db.fin.create.annual.report()</code></li>
<li><code>mgr.db.fin.read.annual.report()</code></li>
</ul>
<p>Functions are always added to the <code>db</code> object within the manager instance. There are two ways to indicate the type of SQL execution that is being performed:</p>
<ul>
<li><strong>An SQL file name can be prefixed with the <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> operation that is being performed (i.e. <code>create</code>, <code>read</code>, <code>update</code> or <code>delete</code>)</strong></li>
<li><strong>A <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> operation can be passed into the <a href="global.html#SQLERPreparedFunction%7D">generated SQL function</a> using the <a href="global.html#SQLERExecOptions"><code>type</code> option</a></strong></li>
</ul>
<p>Defining the <em>type</em> of CRUD operation helps assist implementing <a href="Dialect.html">Dialect</a> to determine any supplemental processing that may need to take place (like transactional state).</p>
<p>Most RDMS drivers support <em>bind variables</em> in some form or fashion. The most common of which is the typical syntax commonly associated with unamed or named bind parameters within an SQL source. However, <code>sqler</code> provides a few substitutional encapsulators that help with SQL function composition. Each SQL file can define multiple encapsulators that indicates what portions of an SQL source will be present before execution takes place. Substitutions use an openening <code>[[</code> and closing <code>]]</code> that can also be optionally prefixed with a SQL line comment <code>--[[</code>. The following sections discuss the differnt type of substitutions in more detail.</p>
<p>The order of precedence in which substitutions are made:</p>
<ol>
<li><strong><a href="#rs">Raw Substitutions</a></strong> - Set when an SQL file is read/cached</li>
<li><strong><a href="#es">Expanded SQL Substitutions</a></strong> - Set during <a href="global.html#SQLERPreparedFunction">prepared function execution</a></li>
<li><strong><a href="#ds">Dialect Substitutions</a></strong> - Set during <a href="global.html#SQLERPreparedFunction">prepared function execution</a></li>
<li><strong><a href="#vs">Version Susbstitutions</a></strong> - Set during <a href="global.html#SQLERPreparedFunction">prepared function execution</a></li>
<li><strong><a href="#fs">Fragment Substitutions</a></strong> - Set during <a href="global.html#SQLERPreparedFunction">prepared function execution</a></li>
</ol>
<h4>1️⃣ Expanded SQL Substitutions <ins id="es"></ins>:</h4>
<p>Depending on the underlying dialect support, named parameters typically follow some form of syntactic grammar like <code>:someParam</code>, where <code>someParam</code> is a parameter passed in to the <code>sqler</code> <a href="global.html#SQLERPreparedFunction%7D">generated SQL function</a> as the <a href="global.html#SQLERExecOptions">bind variables</a>. There may be instances where <em>any</em> number of variables need to be substituded when an SQL function is executed, but the actual number of variables is unknown at the time the SQL script is written. This can be accomplished in <code>sqler</code> by simply adding a single variable to the SQL bind variables and passing them into the prepared function. For instance, passing the following <a href="global.html#SQLERExecOptions">bind variables</a> JSON into the <code>sqler</code> <a href="global.html#SQLERPreparedFunction%7D">generated SQL function</a>:
<br/><br/><strong><a href="global.html#SQLERExecOptions">bind variables</a>:</strong></p>
<pre class="prettyprint source lang-json"><code>{
  &quot;someParam&quot;: [&quot;one&quot;,&quot;two&quot;,&quot;three&quot;]
}
</code></pre>
<p><strong>read.some.query.sql</strong></p>
<pre class="prettyprint source lang-sql"><code>SELECT SOME_COL
FROM SOME_TABLE
WHERE SOME_COL IN (:someParam)
</code></pre>
<p>Would result in the following parameters and SQL execution
<br/><br/><strong><a href="global.html#SQLERExecOptions">bind variables</a> passed into the driver used by the implementing <a href="Dialect.html">Dialect</a>:</strong></p>
<pre class="prettyprint source lang-json"><code>{
  &quot;someParam&quot;: &quot;one&quot;,
  &quot;someParam1&quot;: &quot;two&quot;,
  &quot;someParam2&quot;: &quot;three&quot;
}
</code></pre>
<p><strong>read.some.query.sql ---&gt; read.some.query({ binds })</strong></p>
<pre class="prettyprint source lang-sql"><code>SELECT SOME_COL
FROM SOME_TABLE
WHERE SOME_COL IN (:someParam, :someParam1, :someParam2)
</code></pre>
<p>🆚 Expansions can also use conjunctive <code>AND</code> or <code>OR</code> instead of the previous <em>comma separated</em> expansions.</p>
<pre class="prettyprint source lang-json"><code>{
  &quot;someParam&quot;: [&quot;one&quot;,&quot;two&quot;,&quot;three&quot;]
}
</code></pre>
<p><strong>read.some.query.sql</strong></p>
<pre class="prettyprint source lang-sql"><code>SELECT SOME_COL
FROM SOME_TABLE
WHERE [[OR UPPER(SOME_COL) = UPPER(:someParam)]]
</code></pre>
<p>Would result in the following parameters and SQL execution
<br/><br/><strong><a href="global.html#SQLERExecOptions">bind variables</a> passed into the driver used by the implementing <a href="Dialect.html">Dialect</a>:</strong></p>
<pre class="prettyprint source lang-json"><code>{
  &quot;someParam&quot;: &quot;one&quot;,
  &quot;someParam1&quot;: &quot;two&quot;,
  &quot;someParam2&quot;: &quot;three&quot;
}
</code></pre>
<p><strong>read.some.query.sql ---&gt; read.some.query({ binds })</strong></p>
<pre class="prettyprint source lang-sql"><code>SELECT SOME_COL
FROM SOME_TABLE
WHERE UPPER(SOME_COL) = UPPER(:someParam) OR UPPER(SOME_COL) = UPPER(:someParam1) OR UPPER(SOME_COL) = UPPER(:someParam2)
</code></pre>
<p>The normal driver driven variable substitutions would then be handled/applied external to <code>sqler</code>.</p>
<h4>2️⃣ Fragment Substitutions <ins id="fs"></ins>:</h4>
<p>The second type of replacement involves SQL script segments that are fragmented by use case. An example would be where only a portion of the SQL script will be included when <code>frags</code> is passed into the <a href="global.html#SQLERPreparedFunction%7D">generated SQL function</a> that matches a key found in the SQL script that's surrounded by an open (e.g. <code>[[? someKey]]</code>) and closing (i.e. <code>[[?]]</code>) fragment definition. For instance if <code>frags</code> is passed into a managed SQL function that contains <code>['someKey']</code> for a SQL script:</p>
<pre class="prettyprint source lang-sql"><code>SELECT SOME_COL
FROM SOME_TABLE
WHERE SOME_COL = 'test'
[[? someKey]] AND SOME_COL2 IS NOT NULL [[?]]
</code></pre>
<p>the resulting SQL script will become:</p>
<pre class="prettyprint source lang-sql"><code>SELECT SOME_COL
FROM SOME_TABLE
WHERE SOME_COL = 'test'
AND SOME_COL2 IS NOT NULL
</code></pre>
<p>When <code>frags</code> is omitted or <code>frags</code> contains an array that does not contain a <code>somekey</code> value, then the resulting SQL script would become:</p>
<pre class="prettyprint source lang-sql"><code>SELECT SOME_COL
FROM SOME_TABLE
WHERE SOME_COL = 'test'
</code></pre>
<blockquote>
<p><strong>NOTE: Fragment substitutions cannot be nested</strong></p>
</blockquote>
<h4>3️⃣ Dialect Substitutions <ins id="ds"></ins>:</h4>
<p>A third type of replacement is dialect specific and allows for SQL files that, for the most part are ANSI compliant, but may have slight deviations in syntax that's specific to an individual database vendor. SQL files can coexist between database vendors, but segments of the SQL script will only be included when executed under a database within a defined dialect. An example would be the use of <code>SUBSTR</code> in Oracle versus the ANSI* use of <code>SUBSTRING</code>. A SQL file may contain:</p>
<pre class="prettyprint source lang-sql"><code>SELECT SOME_COL
FROM SOME_TABLE
WHERE
[[! oracle]]
SOME_COL = SUBSTR(SOME_COL, 1, 1)
[[!]]
[[! mssql]]
SOME_COL = SUBSTRING(SOME_COL FROM 1 FOR 1)
[[!]]
</code></pre>
<p>If an <code>oracle</code> dialect were to be used the resulting SQL would become:</p>
<pre class="prettyprint source lang-sql"><code>SELECT SOME_COL
FROM SOME_TABLE
WHERE
SOME_COL = SUBSTR(SOME_COL, 1, 1)
</code></pre>
<p>If a <code>mssql</code> dialect were to be used the resulting SQL would become:</p>
<pre class="prettyprint source lang-sql"><code>SELECT SOME_COL
FROM SOME_TABLE
WHERE
SOME_COL = SUBSTRING(SOME_COL FROM 1 FOR 1)
</code></pre>
<blockquote>
<p><strong>NOTE: Dialect substitutions cannot be nested</strong></p>
</blockquote>
<h4>4️⃣ Version Susbstitutions <ins id="vs"></ins>:</h4>
<p>Sometimes programs connect to DBs that are shared accross one or more applications. Some portions of a program may need to execute SQL scripts that are similar in nature, but have some versioning discrepancies between database instances. Say we have a database instance for an up-and-coming version that has some modifications made to it's structure, but is not enough to warrent two separate copies of the same SQL script file. It may make more sense to maintain one copy of a SQL file and account for the discrepancies within the SQL file. We can do so by encapsulating the SQL segment by surrounding it with an opening <code>[[version = 1]]</code> and closing <code>[[version]]</code> key (valid version quantifiers can be <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> or <code>&lt;&gt;</code>). So, if there were a SQL file that contained:</p>
<pre class="prettyprint source lang-sql"><code>SELECT
[[version &lt;= 1]]
SOME_OLD_COL
[[version]]
[[version > 1]]
SOME_NEW_COL
[[version]]
FROM SOME_TABLE
</code></pre>
<p>When the <code>sqler</code> managed connection configuration contained <code>version</code> with a value of <code>1</code> (or any value less than one) then the resulting SQL would become:</p>
<pre class="prettyprint source lang-sql"><code>SELECT
SOME_OLD_COL
FROM SOME_TABLE
</code></pre>
<p>Likewise, a <code>version</code> of <code>1.5</code> would result in the following SQL:</p>
<pre class="prettyprint source lang-sql"><code>SELECT
SOME_NEW_COL
FROM SOME_TABLE
</code></pre>
<blockquote>
<p><strong>NOTE: Version substitutions cannot be nested</strong></p>
</blockquote>
<h4>5️⃣ Raw Susbstitutions <ins id="rs"></ins>:</h4>
<p>There are some occasions where substitutions need to be made directly on the SQL unconditionally. One such case would be environmental conditions that may warrant the use of raw substitutions. Lets consider a scenario where a SQL file contains a <a href="https://en.wikipedia.org/wiki/Database_schema">schema</a> that is differnt for a <em>production</em> environment than it is in a <em>test</em> environment since they occupy the same <a href="https://en.wikipedia.org/wiki/Tablespace">tablespace</a>. Assuming the SQL is referencing a schema that is not the the default schema where it can be ommitted from the SQL altogether, there would be some challanges to overcome to achieve consistecy in a single SQL file. The subsequent example illustrates how this can be accomplished via the <a href="Manager.html">Manager constructor <code>conf.db.connections[].substitutes</code></a>:</p>
<p><strong>Test environment configuration:</strong></p>
<pre class="prettyprint source lang-json"><code>{
  // other config here
  &quot;db&quot;: {
    // other config here
    &quot;connections&quot;: [
      {
        // other config here
        &quot;substitutes&quot;: {
          &quot;SOME_DB&quot;: &quot;SOME_DB_TEST&quot;
        }
      }
    ]
  }
}
</code></pre>
<pre class="prettyprint source lang-sql"><code>SELECT ST.COME_COL
FROM SOME_DB.SOME_TABLE ST
</code></pre>
<p>When the <code>sqler</code> managed connection configuration contained the previously defined <code>conf.db.connections[].substitutes</code> the resulting SQL would become:</p>
<pre class="prettyprint source lang-sql"><code>SELECT ST.COME_COL
FROM SOME_DB_TEST.SOME_TABLE ST
</code></pre>
<h4>🎬 Transactions <ins id="tx"></ins>:</h4>
<p><a href="https://en.wikipedia.org/wiki/Database_transaction">Transactions</a> are managed by <a href="Dialect.html#beginTransaction">Dialect.beginTransaction</a> and are accessible via <code>await manager.db[myConnectionName].beginTransaction()</code>. Each call to <code>beginTransaction</code> accepts an <em>optional</em> <a href="global.html#SQLERTransactionOptions">Transaction Options</a> argument and returns a unique <a href="global.html#SQLERTransaction">Transaction</a> with an ID that can be passed as the <code>transactionId</code> option in subsequent <a href="global.html#SQLERPreparedFunction">Prepared Function</a> calls. Generated transaction IDs helps to isolate executions to a single open connection in order to prevent inadvertently making changes on database connections used by other transactions that may also be in progress. Amoung other properties, each <a href="global.html#SQLERTransaction">Transaction</a> contains the following functions used to finalize a transaction:</p>
<ul>
<li><code>commit</code> - Commits any pending changes from one or more previously invoked SQL script</li>
<li><code>rollback</code> - Rolls back any pending changes from one or more previously invoked SQL script</li>
</ul>
<p>Calling the the forementioned <code>commit</code> is not always necessary since there are a few different techniques for handling transactions. The simplest form is when executing a single SQL script where the <em>default</em> setting is used for <code>autoCommit = true</code>.</p>
<pre class="prettyprint source lang-js"><code>// autoCommit = true is the default
const coOpts = {
 binds: {
   id: 123,
   name: 'Company 1'
 }
};

// begins/commits a transaction in a
// single step (i.e. autoCommit = true)
const exec1 = await mgr.db.fin.create.ap.company(coOpts);
</code></pre>
<p>Lets say there are multiple SQL scripts that need to be included in a single transaction. To do so, the <code>autoCommit</code> flag can be set to <em>true</em> on the last transaction being executed. Also, to ensure every SQL script that is executed be performed within the same transaction scope, a <code>transactionId</code> should be set to the same value for every SQL execution that needs to be included within the same transaction. Calling <code>const tx = await manager.db.myConnectionName.beginTransaction()</code> will generate/return a <a href="global.html#SQLERTransaction">transaction</a> that contains a unique <code>id</code> that can be passed into each <a href="global.html#SQLERPreparedFunction">prepared function</a> <a href="global.html#SQLERExecOptions">options</a>.</p>
<pre class="prettyprint source lang-js"><code>// autCommit = false requires a transaction to be set
const coOpts = {
  autoCommit: false,
  binds: {
    id: 123,
    name: 'Company 1'
  }
};
// autCommit = true will cause the transaction to be
// automatically committed after execution
const acctOpts = {
  autoCommit: true,
  binds: {
    id: 456,
    name: 'Account 1'
  }
};

let tx;
try {
  // start a transaction
  tx = await mgr.db.fin.beginTransaction();

  // set the transaction ID on the execution options
  // so the company/account SQL execution is invoked
  // within the same transaction scope
  coOpts.transactionId = tx.id;
  acctOpts.transactionId = tx.id;

  // execute within a transaction scope
  // (i.e. autoCommit = false and transactionId = tx.id)
  const exc1 = await mgr.db.fin.create.ap.company(coOpts);

  // execute within the same transaction scope
  // and commit after the satement has executed
  // (i.e. autoCommit = true and transactionId = tx.id)
  const exc2 = await mgr.db.fin.create.ap.account(acctOpts);
} catch (err) {
  if (tx) {
    // use the transaction to rollback the changes
    await tx.rollback();
  }
  throw err;
}
</code></pre>
<p>We could of explicity called commit instead of setting <code>autoCommit</code> to <em>true</em> on the final SQL script execution:</p>
<pre class="prettyprint source lang-js"><code>// autCommit = false will cause a transaction to be started
const coOpts = {
  autoCommit: false,
  binds: {
    id: 123,
    name: 'Company 1'
  }
};
// autCommit = false will cause a transaction to be continued
const acctOpts = {
  autoCommit: false,
  binds: {
    id: 456,
    name: 'Account 1'
  }
};

let tx;
try {
  // start a transaction
  tx = await mgr.db.fin.beginTransaction();

  // set the transaction ID on the execution options
  // so the company/account SQL execution is invoked
  // within the same transaction scope
  coOpts.transactionId = tx.id;
  acctOpts.transactionId = tx.id;

  // execute within the a transaction scope
  // (i.e. autoCommit = false and transactionId = tx.id)
  const exc1 = await mgr.db.fin.create.ap.company(coOpts);

  // execute within the same transaction scope
  // (i.e. autoCommit = false and transactionId = tx.id)
  const exc2 = await mgr.db.fin.create.ap.account(acctOpts);

  // use the transaction to commit the changes
  await tx.commit();
} catch (err) {
  if (tx) {
    // use the transaction to rollback the changes
    await tx.rollback();
  }
  throw err;
}
</code></pre>
<p>The previous transaction examples execute the SQL script in <em>series</em>, but they can also be executed in <em>parallel</em>. However, doing so requires that all the SQL executions use the same <code>transaction</code> and that <code>autoCommit</code> is set to <em>false</em> since <strong>executing in <em>parallel</em> does not guarantee the order in which the SQL scripts are executed</strong>.</p>
<pre class="prettyprint source lang-js"><code>// autCommit = false will cause a transaction to be started
const coOpts = {
  autoCommit: false,
  binds: {
    id: 123,
    name: 'Company 1'
  }
};
// autCommit = false will cause a transaction to be continued
const acctOpts = {
  autoCommit: false,
  binds: {
    id: 456,
    name: 'Account 1'
  }
};

let tx;
try {
  // start a transaction
  tx = await mgr.db.fin.beginTransaction();

  // set the transaction ID on the execution options
  // so the company/account SQL execution is invoked
  // within the same transaction scope
  coOpts.transactionId = tx.id;
  acctOpts.transactionId = tx.id;

  // execute within the same transaction scope
  // (i.e. autoCommit = false and transactionId = tx.id)
  const coProm = mgr.db.fin.create.ap.company(coOpts);

  // execute within the same transaction scope
  // (i.e. autoCommit = false and transactionId = tx.id)
  const acctProm = mgr.db.fin.create.ap.account(acctOpts);

  // wait for the parallel executions to complete
  const exc1 = await coProm;
  const exc2 = await acctProm;

  // use the transaction to commit the changes
  await tx.commit();
} catch (err) {
  if (tx) {
    // use the transaction to rollback the changes
    await tx.rollback();
  }
  throw err;
}
</code></pre>
<blockquote>
<p><strong>It's imperative that <code>commit</code> or <code>rollback</code> be called when using <code>beginTransaction()</code> and <a href="global.html#SQLERExecOptions"><code>autoCommit = false</code> option</a> is set within a transaction since the underlying connection is typically left open until one of those functions are invoked. Not doing so could quickly starve available connections! It's also equally important not to have more transactions in progress than what is available in the connection pool that is being used by the underlying dialect.</strong></p>
</blockquote>
<h4>🍽️ Prepared Statements <ins id="ps"></ins></h4>
<p><a href="https://en.wikipedia.org/wiki/Prepared_statement">Prepared statements</a> <strong>may</strong> optimize SQL execution when invoking the same SQL script multiple times. When bind parameters are used, different values can also be passed into the <a href="global.html#SQLERPreparedFunction">prepared function</a>.</p>
<p>In <code>sqler</code>, prepared statements are handled internally via a chosen <a href="Dialect.html">Dialect</a> vendor implementation. Only the <a href="global.html#SQLERExecOptions"><code>prepareStatement = true</code> flag</a> needs to be set to indicate the underlying SQL script should be executed within a <strong>dedicated request and/or connection</strong> from the pool. Once all of the SQL invokations are complete a call to <code>unprepare</code> from the <a href="global.html#SQLERExecResults">execution result</a> will ensure the statement/connection is closed.</p>
<p>Lets consider the following examples:</p>
<pre class="prettyprint source lang-js"><code>// prepareStatemnt = true will create a prepared statement
const coOpts1 = {
  prepareStatemnt: true,
  binds: {
    id: 1,
    name: 'Company 1'
  }
};
// prepareStatemnt = true will use the in-progress prepared statement
const coOpts2 = {
  prepareStatemnt: true,
  binds: {
    id: 2,
    name: 'Company 2'
  }
};

let exc1, exc2;
try {
  // prpare statement and execute the SQL script
  // (i.e. prepareStatement = true)
  const coProm1 = mgr.db.fin.create.ap.company(coOpts1);
  const coProm2 = mgr.db.fin.create.ap.company(coOpts2);

  // wait for the parallel executions to complete
  exc1 = await coProm1;
  exc2 = await coProm2;
} finally {
  if (exc1) {
    // can call either exc1.unprepare() or exc2.unprepare()
    await exc1.unprepare();
  }
}
</code></pre>
<p>Prepared statements can also be contained within a <a href="#tx">transaction</a>. When doing so, calls to <code>commit</code> or <code>rollback</code> on the <a href="global.html#SQLERTransaction">transaction</a> will <em>implicitly</em> call <code>unprepare</code> for each <a href="global.html#SQLERExecResults">execution result</a> that used the same <a href="global.html#SQLERTransaction">transaction</a> on the <a href="global.html#SQLERExecOptions">execution options</a> that is passed into the <a href="global.html#SQLERPreparedFunction">prepared function</a>.</p>
<pre class="prettyprint source lang-js"><code>// autCommit = false will cause a transaction to be started
// prepareStatemnt = true will create a prepared statement
const coOpts1 = {
  autoCommit: false,
  prepareStatemnt: true,
  binds: {
    id: 1,
    name: 'Company 1'
  }
};
// autCommit = false will cause a transaction to be continued
// prepareStatemnt = true will use the in-progress prepared statement
const coOpts2 = {
  autoCommit: false,
  prepareStatemnt: true,
  binds: {
    id: 2,
    name: 'Company 2'
  }
};

let tx;
try {
  // start a transaction
  tx = await mgr.db.fin.beginTransaction();

  // set the transaction ID on the execution options
  // so the company/account SQL execution is invoked
  // within the same transaction scope
  coOpts1.transactionId = tx.id;
  coOpts2.transactionId = tx.id;

  // execute within the same transaction scope
  // (i.e. autoCommit === false, transactionId = tx.id, prepareStatement = true)
  const coProm1 = mgr.db.fin.create.ap.company(coOpts1);
  const coProm2 = mgr.db.fin.create.ap.account(coOpts2);

  // wait for the parallel executions to complete
  const exc1 = await coProm1;
  const exc2 = await coProm2;

  // use the transaction to commit the changes
  // (commit will implicitly invoke unprepare)
  await tx.commit();
} catch (err) {
  if (tx) {
    // use the transaction to commit the changes
    // (rollback will implicitly invoke unprepare)
    await tx.rollback();
  }
  throw err;
}
</code></pre>
<blockquote>
<p><strong>It's imperative that <code>unprepare</code> (or <code>commit</code>/<code>rollback</code> when using a <a href="#tx">transaction</a>) is called when using <a href="global.html#SQLERExecOptions"><code>prepareStatement = true</code> is set</a> since the underlying connection is typically left open until the <code>unprepare</code> function is invoked. Not doing so could quickly starve available connections! It's also equally important not to have more <strong>active</strong> prepared statements in progress than what is available in the connection pool that is being used by the underlying dialect.</strong></p>
</blockquote>
<h4>💧 Read/Write Streams <ins id="streams"></ins>:</h4>
<p><a href="https://nodejs.org/api/stream.html">Streaming</a> is a useful technique for reading/writting a large number of records and is very similar to normal reads/writes using the <a href="global.html#SQLERExecOptions"><code>stream</code> option</a>. The value set on <code>execOpts.stream</code> will indicate to the underlying database dialect that the desired batch size for executions should match that of the <code>stream</code> value. Just keep in mind that there is a balance between the batch size stored in memory that accumulates until the <code>stream</code> threshold is met, and the total number of executions for all batches. So, it's a good practice to use smaller <code>stream</code> batch values to keep a smaller memory footprint. But, large enough that minimize round trips to the dialect backend.</p>
<p>During read or write streaming, it's possible to capture the the data that is being read or written for a given <code>stream</code> batch. Simply, listen for the <code>typedefs.EVENT_STREAM_BATCH</code> event on the desired readable or writable stream returned by the execution (see example below). The array of batch values should reflect either the read records or results of the written executions (e.g. like <em>rows affected</em>). In addition to the read and write events for the stream and dialect driver (if any), there are a few additional <code>sqler</code> specific events that are <em>typically</em> emitted:</p>
<ul>
<li><strong><code>typedefs.EVENT_STREAM_BATCH</code></strong> - Emitted for each batch of read data <code>Object[]</code> for a <code>stream.Readable</code> or write binds <code>Object[]</code> for a <code>stream.Writable</code>.</li>
<li><strong><code>typedefs.EVENT_STREAM_RELEASE</code></strong> - Emitted when a read or write stream has released or closed it's connection.</li>
</ul>
<p>Example reads:</p>
<pre class="prettyprint source lang-js"><code>const typedefs = require('sqler/typedefs');

// tell sqler to return stream.Readable
// stream can be >= 0 to indicate streaming
const rslts = await mgr.db.myconn.read.something({ stream: 0 });
// rows are one or more stream.Readable
for (let readStream of rslts.rows) {
  // not required, but we can listen to when the connection for the stream
  // has been release or closed
  readStream.on(typedefs.EVENT_STREAM_RELEASE, () => {
    console.log('My read stream connection has been released');
  });
  // aync iterate over the stream.Readable to capture the rows
  for await (const row of readStream) {
    console.log('My read row', row);
  }
}
</code></pre>
<p>Example writes:</p>
<pre class="prettyprint source lang-js"><code>const typedefs = require('sqler/typedefs');
const Stream = require('stream');
// node >= v16 :
// const { pipeline } = require('stream/promises');
// node &lt; 16 :
const Util = require('util');
const pipeline = Util.promisify(Stream.pipeline);

// tell sqler to return stream.Writable
// stream can be >= 0 to indicate sreaming
// with a count > 0, increments of that size will be emitted via event
const rslts = await mgr.db.myconn.update.something({ stream: 100 });
// rows are one or more stream.Writable
for (let writeStream of rslts.rows) {
  // not required, but we can listen to when the connection for the stream
  // has been release or closed
  writeStream.on(typedefs.EVENT_STREAM_RELEASE, () => {
    console.log('My write stream connection has been released');
  });
  // not required, but we can listen to when batches have been written
  writeStream.on(typedefs.EVENT_STREAM_WRITTEN_BATCH, async (bindsArray) => {
    console.log('Every 100 batched results array:', bindsArray);
  });
  await pipeline(
    Stream.Readable.from(async function* reads() {
      for (let i = 0; i &lt; 10000 /* lets generates some records */; i++) {
        yield { myField: i };
      }
    }()),
    writeStream
  );
}
</code></pre>
<p>Streams can also be used in conjunction with <a href="#ps">prepared statements</a> <strong>and/or</strong> <a href="#tx">transactions</a>.</p>
<pre class="prettyprint source lang-js"><code>const typedefs = require('sqler/typedefs');
const Stream = require('stream');
// node >= v16 :
// const { pipeline } = require('stream/promises');
// node &lt; 16 :
const Util = require('util');
const pipeline = Util.promisify(Stream.pipeline);


let tx;
try {
  // start a transaction
  tx = await mgr.db.myconn.beginTransaction();

  // transaction, prepared statement and write stream options
  const execOpts = {
    stream: 100, // stream batch count is for streaming, not the transaction!
    autoCommit: false, // transaction will be committed manually
    transactionId: tx.id, // use the started transaction
    prepareStatemnt: true // generate a prepared statement
  };

  const rslts = await mgr.db.myconn.update.something(execOpts);
  // rows are one or more stream.Writable
  for (let writeStream of rslts.rows) {
    // not required, but we can listen to when has been prepared
    writeStream.on(typedefs.EVENT_STREAM_STATEMENT_PREPARED, async () => {
      console.log('Prepared statement has been prepared');
    });
    // not required, but we can listen to when has been unprepared
    writeStream.on(typedefs.EVENT_STREAM_STATEMENT_UNPREPARED, async () => {
      console.log('Prepared statement has been unprepared');
    });
    // not required, but we can listen to when batches have been written
    writeStream.on(typedefs.EVENT_STREAM_WRITTEN_BATCH, async (rsltsArray) => {
      console.log('Every 100 batched results array:', rsltsArray);
    });
    await pipeline(
      Stream.Readable.from(async function* reads() {
        for (let i = 0; i &lt; 10000 /* lets generates some records */; i++) {
          yield { myField: i };
        }
      }()),
      // example transform that adds a timestamp to every record to be written
      async function* transformStringify(chunksAsync) {
        for await (const chunk of chunksAsync) {
          chunk.myDate = new Date();
          yield chunk;
        }
      },
      writeStream
    );
  }

  // other executions can be performed within the same transaction
  const coProm2 = mgr.db.myconn.create.something({
    autoCommit: false, // transaction will be committed manually
    transactionId: tx.id, // use the same transaction
    binds: { id: 'some_id' }
  });

  // use the transaction to commit the changes
  // (commit will implicitly invoke unprepare)
  await tx.commit();
} catch (err) {
  if (tx) {
    // use the transaction to commit the changes
    // (rollback will implicitly invoke unprepare)
    await tx.rollback();
  }
  throw err;
}
</code></pre>
<blockquote>
<p>NOTE : Read streams expect <a href="https://nodejs.org/api/stream.html#stream_readable_readableobjectmode"><code>objectMode = true</code></a>. Write streams expect <a href="https://nodejs.org/api/stream.html#stream_writable_writableobjectmode"><code>objectMode = true</code></a>.</p>
</blockquote>
<h4>🗄️ Caching SQL <ins id="cache"></ins>:</h4>
<p>By default all SQL files are read once during <a href="Manager.html#init">Manager.init</a>, but there are other options for controlling the frequency of the SQL file reads by passing a <a href="global.html#SQLERCache">cache container (see example)</a> into the <a href="Manager.html#Manager">Manager constructor</a> or by calling <a href="Manager.html#setCache">Manager.setCache</a>.</p>
<p>Since <code>sqler</code> expects SQL files to be defined prior to <a href="Manager.html#init">initialization</a>, there are several techniques that can be used to produce and maintain evolving SQL statements:</p>
<ol>
<li>Add/generate SQL files before <a href="Manager.html#init">Manager.init</a></li>
<li>Add/generate SQL files, then add the connection for them later using <a href="Manager.html#addConnection">Manager.addConnection</a></li>
</ol>
<p>If using any of the forementioned strategies isn't enough, SQL files can be changed and either the SQL key can be dropped from the cache or the entire cache can be removed (and alternately set back):</p>
<pre class="prettyprint source lang-js"><code>// see SQLERCache for setting up a cache
const mgr = new Manager(conf, cache);
await mgr.init();
// ... make some changes to the SQL files here

// ===== Option 1 =====
// drop the key from the cache for the SQL file
// being changed
const key = await mgr.getCacheKey('/absolute/path/to/sql/file.sql', 'myConnName');
cache.drop(key);

// ===== Option 2 =====
// clear the entire cache so that all SQL
// files will be read on the next execution
await mgr.setCache(null, 'myConnName');
// set the cache back?
await mgr.setCache(cache, 'myConnName');
</code></pre>
</article>

</section>

</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<div id="jsdocpChangelogContent" data-title="CHANGELOG v8.1.0">
  <svg class="jsdocp-close" id="jsdocpChangelogClose" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
  </svg>
  <h2><a href="https://ugate.github.io/sqler/tree/v8.1.0">8.1.0</a> (2021-08-16)</h2>
<p><a href="https://ugate.github.io/sqler/compare/v8.0.0...v8.1.0">Full Changelog</a></p>
<p><strong>Fixes:</strong></p>
<ul>
<li><a href="https://ugate.github.io/sqler/commit/0c5306c7f1ce8ac88506ffc7e10bc0172e7de279">[FIX]: Added typedefs.EVENT_STREAM_RELEASE support</a></li>
</ul>
</div>



<script src="jsdocp/scripts/index.js"></script></body>
</html>